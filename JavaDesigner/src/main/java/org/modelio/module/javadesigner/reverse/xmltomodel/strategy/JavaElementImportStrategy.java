package org.modelio.module.javadesigner.reverse.xmltomodel.strategy;

import java.util.List;
import com.modelio.module.xmlreverse.IReadOnlyRepository;
import com.modelio.module.xmlreverse.model.JaxbElementImport;
import com.modelio.module.xmlreverse.model.JaxbStereotype;
import com.modelio.module.xmlreverse.strategy.ElementImportStrategy;
import org.modelio.api.modelio.model.IModelingSession;
import org.modelio.metamodel.uml.infrastructure.ModelElement;
import org.modelio.metamodel.uml.infrastructure.ModelTree;
import org.modelio.metamodel.uml.statik.AssociationEnd;
import org.modelio.metamodel.uml.statik.Attribute;
import org.modelio.metamodel.uml.statik.Classifier;
import org.modelio.metamodel.uml.statik.ElementImport;
import org.modelio.metamodel.uml.statik.GeneralClass;
import org.modelio.metamodel.uml.statik.Generalization;
import org.modelio.metamodel.uml.statik.Interface;
import org.modelio.metamodel.uml.statik.InterfaceRealization;
import org.modelio.metamodel.uml.statik.NameSpace;
import org.modelio.metamodel.uml.statik.Operation;
import org.modelio.metamodel.uml.statik.Parameter;
import org.modelio.metamodel.uml.statik.RaisedException;
import org.modelio.metamodel.uml.statik.TemplateParameter;
import org.modelio.module.javadesigner.api.IJavaDesignerPeerModule;
import org.modelio.module.javadesigner.api.JavaDesignerStereotypes;
import org.modelio.module.javadesigner.api.JavaDesignerTagTypes;
import org.modelio.module.javadesigner.reverse.ReverseStrategyConfiguration;
import org.modelio.module.javadesigner.reverse.common.WellKnownContainerServices;
import org.modelio.module.javadesigner.utils.IOtherProfileElements;
import org.modelio.module.javadesigner.utils.JavaDesignerUtils;

public class JavaElementImportStrategy extends ElementImportStrategy {
    private ReverseStrategyConfiguration reverseConfig;

    public JavaElementImportStrategy(final IModelingSession session, final ReverseStrategyConfiguration reverseConfig) {
        super (session);
        this.reverseConfig = reverseConfig;
    }

    @Override
    public ElementImport getCorrespondingElement(final JaxbElementImport jaxb_element, final NameSpace source, final NameSpace target, final IReadOnlyRepository repository) {
        // Search for an element import between those elements
        for (ElementImport link: source.getOwnedImport()) {
            if (!repository.isRecordedElement(link)) {
                NameSpace targetNameSpace = link.getImportedElement();
                if (targetNameSpace.equals(target)) {
                       // check for JAVASTATIC stereotype
                    if (isStatic(jaxb_element) == link.isStereotyped(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerStereotypes.JAVASTATIC)) {
                       return link;
                    }
        
                }
            }
        }
        
        // No link found, create a new one
        return this.model.createElementImport();
    }

    /**
     * Tell if jaxb_element is stereotyped JAVASTATIC
     */
    private boolean isStatic(final JaxbElementImport jaxb_element) {
        for(Object c : jaxb_element.getNoteOrConstraintOrStereotype()) {
            if (c instanceof JaxbStereotype && JavaDesignerStereotypes.JAVASTATIC.equals(((JaxbStereotype)c).getStereotypeType())) {
                return true;
            }
            
        }
        return false;
    }

    /**
     * Remove all imports that can be deduced from the model. In other words it means remove all the imports generated by
     * ClassTemplate.getClassImport (except, obviously, the imported element part)
     * In more details, remove for the current source and all its recursively owned GeneralClass, the import if its destination is :
     * - the default type of a template parameter
     * - the super class of a generalization
     * - an implemented interface
     * - the type of a return parameter of an operation
     * - the type of an IO parameter of an operation
     * - the default type of an operation template parameter
     * - the thrown type of an operation raised exception
     * - the type of an attribute not tagged JavaTypeExpr or JavaFullName
     * - the destination of a navigable association not tagged JavaTypeExpr or JavaFullName
     * - the type of a navigable association qualifier
     * - a well known container
     * @see ClassTemplate.getClassImport.ClassTemplate method getClassImport
     */
    @Override
    public void postTreatment(final JaxbElementImport jaxb_element, final ElementImport modelio_element, final IReadOnlyRepository repository) {
        if (modelio_element.getImportingNameSpace() != null) {
            super.postTreatment (jaxb_element, modelio_element, repository);
        }
        
        
        if (!modelio_element.isValid()) {
            // modelio_element already deleted by super
            return;
        }
        
        // Ignore targets that are not GeneralClasses.
        NameSpace target = modelio_element.getImportedElement();
        if (target instanceof GeneralClass == false) {
            return;
        }
        
        // Ignore sources that are not GeneralClasses, like Packages...
        ModelElement source = modelio_element.getImportingNameSpace ();
        if (source == null || source instanceof GeneralClass == false) {
            return;
        }
        
        // Ignore static import
        if (modelio_element.isStereotyped(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerStereotypes.JAVASTATIC)) {
            return;
        }
        
        // Delete unnecessary imports
        if (isImplicitlyGenerated((GeneralClass)source, (GeneralClass)target)) {
            modelio_element.delete();
        }
    }

    private boolean isImplicitlyGenerated(final GeneralClass source, final GeneralClass target) {
        // Template Parameter
        for (TemplateParameter templateParameter : source.getTemplate ()) {
            // TODO template 'type'/'default type' management is messy, we need to homogenize it
            if (!isFullNameGeneration(templateParameter)) {
                ModelElement defaultType = templateParameter.getType ();
                if (defaultType != null && defaultType instanceof GeneralClass && defaultType.equals(target)) {
                    return true;
                }
            }
        }
        
        // Inheritance
        for (Generalization theGeneralization : source.getParent ()) {
            if (!JavaDesignerUtils.isNoCode(theGeneralization) && !isFullNameGeneration(theGeneralization)) {
                NameSpace superType = theGeneralization.getSuperType();
                if (superType instanceof GeneralClass && superType.equals(target)) {
                    return true;
                }
            }
        }
        
        
        // Implementations
        for (InterfaceRealization theRealization : source.getRealized ()) {
            if (!JavaDesignerUtils.isNoCode(theRealization) && !isFullNameGeneration(theRealization)) {
                Interface superType = theRealization.getImplemented();
                if (superType.equals(target)) {
                    return true;
                }
            }
        }
        
        // Operations
        for (Operation theOperation : source.getOwnedOperation()) {
            if (!JavaDesignerUtils.isNoCode (theOperation)) { // Ignore no code
                // Returned parameter
                Parameter returnedParameter = theOperation.getReturn ();
                if (returnedParameter != null &&
                        !isFullNameGeneration (returnedParameter) &&
                        !returnedParameter.isTagged(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerTagTypes.PARAMETER_JAVATYPEEXPR)) {
                    GeneralClass returnedType = returnedParameter.getType ();
                    if (returnedType != null) {
                        if (isWellKnownContainerImport(returnedParameter, target)) {
                            return true;
                        }
                        if (returnedType.equals(target) && !returnedParameter.isTagged(IOtherProfileElements.MODULE_NAME, "type")) {
                            return true;
                        }
                    }
                }
        
                // IO parameter
                for (Parameter theParameter : theOperation.getIO ()) {
                    if (!isFullNameGeneration (theParameter) &&
                            !theParameter.isTagged(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerTagTypes.PARAMETER_JAVATYPEEXPR)) {
                        GeneralClass parameterType = theParameter.getType ();
                        if (parameterType != null) {
                            if (parameterType.equals(target) && !theParameter.isTagged(IOtherProfileElements.MODULE_NAME, "type")) {
                                return true;
                            }
                            if (isWellKnownContainerImport(theParameter, target)) {
                                return true;
                            }
                        }
                    }
                }
        
                // Template parameters
                for (TemplateParameter templateParameter : theOperation.getTemplate ()) {
                    // TODO template 'type'/'default type' management is messy, we need to homogenize it
                    if (!isFullNameGeneration(templateParameter)) {
                        ModelElement defaultType = templateParameter.getDefaultType ();
                        if (defaultType != null && defaultType instanceof GeneralClass) {
                            if (defaultType.equals(target)) {
                                return true;
                            }
                        }
                    }
                }
        
                // Raised exception
                for (RaisedException theException : theOperation.getThrown ()) {
                    if (!isFullNameGeneration (theException)) {
                        Classifier thrownType = theException.getThrownType ();
                        if (thrownType.equals(target)) {
                            return true;
                        }
                    }
                }
        
            }
        
            // Attributes
            for (Attribute theAttribute : source.getOwnedAttribute()) {
                if (!JavaDesignerUtils.isNoCode (theAttribute)) { // Ignore no code
                    if (!isFullNameGeneration (theAttribute) && !theAttribute.isTagged(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerTagTypes.ATTRIBUTE_JAVATYPEEXPR)) {
                        GeneralClass theType = theAttribute.getType ();
                        if (theType != null) {
                            if (isWellKnownContainerImport(theAttribute, target)) {
                                return true;
                            }
        
                            if (theType.equals(target) && !theAttribute.isTagged(IOtherProfileElements.MODULE_NAME, "type")) {
                                return true;
                            }
                        }
                    }
        
                }
            }
        
            // AssociationEnds
            for (AssociationEnd theAssociationEnd : source.getOwnedEnd()) {
                if (!JavaDesignerUtils.isNoCode (theAssociationEnd)) { // Ignore no code
                    if (!isFullNameGeneration (theAssociationEnd) &&
                            !theAssociationEnd.isTagged(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerTagTypes.ASSOCIATIONEND_JAVATYPEEXPR)) {
        
                        if (theAssociationEnd.isNavigable ()) {
                            Classifier destination = theAssociationEnd.getTarget();
                            if (destination != null) {
                                if (isWellKnownContainerImport(theAssociationEnd, target)) {
                                    return true ;
                                }
                                if (destination.equals(target) && !theAssociationEnd.isTagged(IOtherProfileElements.MODULE_NAME, "type")) {
                                       return true;
                                }
                            }
                            for (Attribute qual : theAssociationEnd.getQualifier()) {
                                if (!isFullNameGeneration (qual) && !qual.isTagged(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerTagTypes.ATTRIBUTE_JAVATYPEEXPR)) {
                                    GeneralClass theType = qual.getType ();
                                    if (theType != null && theType.equals(target)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Inner classes
        for (ModelTree ownedElement : source.getOwnedElement ()) {
            if (ownedElement instanceof GeneralClass) {
                if (isImplicitlyGenerated((GeneralClass)ownedElement, target)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isWellKnownContainerImport(final ModelElement aFeatureOrParameter, final GeneralClass anImportedElt) {
        List<String>typepars = aFeatureOrParameter.getTagValues(IOtherProfileElements.MODULE_NAME, IOtherProfileElements.FEATURE_TYPE);
        if (typepars != null && !typepars.isEmpty()) {
            String wkc = typepars.get(0);
            if (wkc != null && wkc.equals(anImportedElt.getName()) && WellKnownContainerServices.isWellKnownContainer(wkc)) {
                return true;
            }
        }
        return false;
    }

    private boolean isFullNameGeneration(final ModelElement theModelElement) {
        boolean value = this.reverseConfig.FULLNAMEGENERATION;
        return  value && theModelElement.isTagged(IJavaDesignerPeerModule.MODULE_NAME, JavaDesignerTagTypes.PARAMETER_JAVAFULLNAME);
    }

}
